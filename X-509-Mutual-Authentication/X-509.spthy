theory x_509
begin

functions: CEOgen/1
builtins: asymmetric-encryption, signing, symmetric-encryption

rule InitInitiatorKeys:  
    [ Fr(~skI), Fr(idI) ]  
  --[ InitInitiatorKeys(~skI, pk(~skI), idI), 
    Honest(idI) ]->
    [ Out(pk(~skI)), 
    !RegisterInitiatorKey_Honest(~skI, pk(~skI), idI) ]  

rule InitResponderKeys:  
    [ Fr(~skR), Fr(idR) ]  
  --[ InitResponderKeys(~skR, pk(~skR), idR), 
    Honest(idR) ]->
    [ Out(pk(~skR)), 
    !RegisterResponderKey_Honest(~skR, pk(~skR), idR) ]  


rule CorruptInitiatorKeys:  // Dishonest Initiator
    [ Fr(~k), Fr(idCI) ]  // Attacker-provided private key and identity for Initiator
  --[ 
     RegisterInitiatorKey_Corrupt(~k, pk(~k), idCI), 
    Corrupt(idCI) 
     ]->
    [ Out(pk(~k)) ] 

rule CorruptResponderKeys:  // Dishonest Responder
    [ Fr(~k), Fr(idCR) ]     // Attacker-provided private key and identity for Responder
  --[ RegisterResponderKey_Corrupt(~k, pk(~k), idCR), 
    Corrupt(idCR) ]->
    [ Out(pk(~k)) ]       


rule I1:
    [ Fr(~k1), 
      Fr(~t), 
      Fr(~req), 
      Fr(~certI), 
      !RegisterInitiatorKey_Honest(~skI, pk(~skI), idI),
      !RegisterResponderKey_Honest(~skR, pkR, idR) ]  
  --[ 
        SendInitiator(~certI, ~t, senc(~req, ~k1), aenc(~k1, pk(~skR)), sign(<~req, ~t>,~skI))
    ]->
    [ Out(~certI),                           // Certificate of Initiator
      Out(~t),                              // Timestamp
      Out(senc(~req, ~k1)),                 // Symmetric encryption of REQ
      Out(aenc(~k1, pk(~skR))),             // Asymmetric encryption of k1
      Out(sign(<~req, ~t>,~skI)),
      Initiator(~skI, pk(~skI), idI, ~certI, ~k1, ~t, ~req) ]         // Digital signature





















//If there are two InitiatorKey (i.e., two key registrations) for the Initiator, their private keys (skI1 and skI2) must be the same.
//Consequently, their public keys (pkI1 and pkI2) will also be the same, since public keys are derived from private keys.
restriction UniqueInitiatorKey:
    "All skI1 skI2 pkI1 pkI2 idI #t1 #t2.
    InitInitiatorKeys(skI1, pkI1, idI) @ t1 & 
    InitInitiatorKeys(skI2, pkI2, idI) @ t2 
    ==> skI1 = skI2"

restriction UniqueResponderKey:
    "All skR1 skR2 pkR1 pkR2 idR #t1 #t2.
    InitResponderKeys(skR1, pkR1, idR) @ t1 & 
    InitResponderKeys(skR2, pkR2, idR) @ t2 
    ==> skR1 = skR2"

lemma UniqueInitiatorKey:
    "All skI1 skI2 pkI1 pkI2 idI #t1 #t2.
    InitInitiatorKeys(skI1, pkI1, idI) @ t1 & 
    InitInitiatorKeys(skI2, pkI2, idI) @ t2 
    ==> skI1 = skI2 & pkI1 = pkI2"

lemma UniqueResponderKey:
    "All skR1 skR2 pkR1 pkR2 idR #t1 #t2.
    InitResponderKeys(skR1, pkR1, idR) @ t1 & 
    InitResponderKeys(skR2, pkR2, idR) @ t2 
    ==> skR1 = skR2 & pkR1 = pkR2"

//Whenever a key registration happens honestly, the protocol explicitly tracks the corresponding identity (id) as honest.
lemma HonestKeyRegistration:
    "All id ska pka #t.
    InitInitiatorKeys(ska, pka, id) @ t & InitResponderKeys(ska, pka, id) @ t
    ==> Honest(id) @ t"

lemma CorruptKeyRegistration:
    "All id ska pka #t.
    RegisterInitiatorKey_Corrupt(ska, pka, id) @ t & RegisterResponderKey_Corrupt(ska, pka, id) @ t
    ==> Corrupt(id) @ t"


end